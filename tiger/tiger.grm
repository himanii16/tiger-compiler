(* user declaration here *)

%%
(* parser declarations *)
%pos int
%eop EOF  (* end of parsing *)
%verbose  (* Generates a printed form of the table in expr.grm.desc *)


(* BRAC - [] , BRACE - {} , PAREN - ()*)

%term NIL
    | ID of string
    | INT of int
    | STRING of string
    | MUL | DIV | PLUS | MINUS | GEQ | LEQ | EQ | NEQ | GT | LT | AND | OR
    | ARRAY | IF | THEN | ELSE | WHILE | FOR | TO | DO | LET | IN | END | OF 
    | BREAK | FUNCTION | VAR | TYPE | IMPORT | PRIMITIVE | ASSIGN 
    | COLON | SEMICOLON | LBRAC | RBRAC | LPAREN | RPAREN | LBRACE | RBRACE  
    | COMMA | DOT | EOF 

%nonterm EXP     of Ast.exp 
       | EXPS    of Ast.exp list
       | DEC     of Ast.dec
       | DECS    of Ast.dec list
       | PROGRAM of Ast.program list 
       | PARAM   of Ast.exp list
       | LVALUE  of Ast.Lvalue 
       | RECORD  of Ast.RecordExp
       | ARGS    of STRING*Ast.exp list
       | TYPEDEC of Ast.TypeDec
       | FUNCDEC  of Ast.FuncDec
       | VARDEC  of Ast.VarDec
       | TY      of Ast.typ
       | TYFIELD of Ast.typefield

%start PROGRAM

%noshift EOF
%nonassoc ASSIGN
%nonassoc SEMICOLON 
%nonassoc DO 
%right THEN
%right ELSE
%nonassoc OF
%left OR
%left AND
%left DOT
%nonassoc EQ NEQ LT LEQ GT GEQ
%left PLUS MINUS
%left MUL DIV

%prefer THEN ELSE LPAREN

%%
(* grammar rules *)

PROGRAM : EXP                 (PROGRAM)

EXPS :                         ([])
     | EXP SEMICOLON EXPS      (EXP :: EXPS)

EXP : NIL                   (Ast.nil)
    | ID                    (Ast.ID)
    | INT                   (Ast.IntConst)
    | LVALUE                (LVALUE)
    | RECORD                (RECORD)
    | EXP PLUS EXP          (Ast.BinOpExp ({left = EXP1, oper = A.Plus, right = EXP2}))
    | EXP MINUS EXP         (Ast.BinOpExp ({left = EXP1, oper = A.Minus, right = EXP2}))
    | EXP MUL EXP           (Ast.BinOpExp ({left = EXP1, oper = A.Mul, right = EXP2}))
    | EXP DIV EXP           (Ast.BinOpExp ({left = EXP1, oper = A.Div, right = EXP2}))
    | EXP GEQ EXP           (Ast.BinOpExp ({left = EXP1, oper = A.GEQ, right = EXP2}))
    | EXP LEQ EXP           (Ast.BinOpExp ({left = EXP1, oper = A.LEQ, right = EXP2}))
    | EXP EQ EXP            (Ast.BinOpExp ({left = EXP1, oper = A.EQ, right = EXP2}))
    | EXP NEQ EXP           (Ast.BinOpExp ({left = EXP1, oper = A.NEQ, right = EXP2}))
    | EXP GT EXP            (Ast.BinOpExp ({left = EXP1, oper = A.GT, right = EXP2}))
    | EXP LT EXP            (Ast.BinOpExp ({left = EXP1, oper = A.LT, right = EXP2}))
    | EXP AND EXP           (Ast.BinOpExp ({left = EXP1, oper = A.AND, right = EXP2}))
    | EXP OR EXP            (Ast.BinOpExp ({left = EXP1, oper = A.OR, right = EXP2}))
    | ID LPAREN PARAM RPAREN   (Ast.FuncCall ({name: ID, arguments: PARAM}))
    | ID LBRAC EXP RBRAC OF EXP (Ast.ArrExp ({name: ID, size: EXP1, init: EXP2}))
    | LPAREN EXP SEMICOLON EXPS RPAREN    (Ast.SeqExp (EXP::EXPS)) 
    | IF EXP THEN EXP ELSE EXP  (Ast.IfExp ({test: EXP1, then: EXP2, otherwise: EXP3}))
    | IF EXP THEN EXP           (Ast.IfThenExp ({test: EXP1, then: EXP2}))
    | WHILE EXP DO EXP          (Ast.WhileExp ({{test: EXP1, body: EXP2}}))
    | FOR ID ASSIGN EXP TO EXP DO EXP (Ast.ForExp ({{variable: ID, init: EXP1, final: EXP2, body: EXP3}}))
    | BREAK                      (Ast.BreakExp)
    | LET DECS IN EXPS END       (Ast.LetExp ({decl: DECS, body: EXPS}))
    | LPAREN EXP RPAREN          (EXP)


PARAM : EXP                   ([EXP])
    | EXP COMMA PARAM       (EXP :: PARAM)

DEC : TYPEDEC               (TYPEDEC)
    | FUNCDEC               (FUNCDEC) 
    | VARDEC                (VARDEC)

DECS :                      ([])
    | DEC DECS              (DEC :: DECS)

LVALUE :                        (Ast.SimpleVar (ID))
       | LVALUE DOT ID          (Ast.FieldVar (LVALUE, ID))
       | ID LBRAC EXP RBRAC     (Ast.ArrVar (ID, EXP))

RECORD : ID NIL                 (Ast.RecordExp ({name: ID, field: []}))
       | ID LBRACE ARGS RBRACE  (Ast.RecordExp ({name: ID, field: ARGS}))

ARGS : (*EMPTY*)                (NIL)
     | STRING EQ EXP            (ID, EXP :: NIL)
     | ARGS COMMA ID EQ EXP     (ID, EXP :: ARGS)

TYPEDEC : TYPE ID EQ TY         (Ast.Typef ({name: ID, ty: TY}))

FUNCDEC : FUNCTION ID LPAREN TYFIELD RPAREN EQ EXP (Ast.Funcf ({name: ID, arguments: TYFIELD, result_type: NONE, body: EXP}))
        | FUNCTION ID LPAREN TYFIELD RPAREN COLON ID EQ EXP (Ast.Funcf ({name: ID1, arguments: TYFIELD, result_type: SOME ID2, body: EXP}))

VARDEC : VAR ID ASSIGN EXP              (Ast.Varf ({name: ID, ty: NONE, init: EXP}))
       | VAR ID COLON ID ASSIGN EXP     (Ast.Varf ({name: ID1, ty: SOME ID2, init: EXP}))

TY : ID                         (Ast.alias (ID))
   | LBRACE TYFIELD RBRACE      (Ast.record (TYFIELD))
   | ARRAY OF ID                (Ast.arr (ID))

TYFIELD : (*EMPTY*)                 ([])
        | ID COLON ID               ([(ID1,ID2)])
        | ID COLON ID COMMA TYFIELD ((ID1,ID2) :: TYFIELD)

