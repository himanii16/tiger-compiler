type lineNo            = int
type pos               = lineNo  (* The type of Should match with expr.yacc *)
val  lineRef           = ref 0   (* reference variable to keep track of position.*)
val  posRef            = ref 0


fun updateLine n      = lineRef := !(lineRef) + n
fun updatepos  n      = posRef := !(posRef) + n 
fun resetpos ()       = posRef := 0
(* Stuff done to make use of the Tokens module generated by expr.grm *)

type svalue        = Tokens.svalue
type ('a,'b) token = ('a,'b) Tokens.token
type lexresult     = (svalue,pos) token

fun eof   ()      = Tokens.EOF (!lineRef,!posRef)


fun charsToInt m (x :: xs) = charsToInt (10 * m + ord x - ord #"0") xs
  | charsToInt m []        = m

fun toSigned (#"-" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"~" :: xs) = ~ (charsToInt 0 xs)
  | toSigned (#"+" :: xs) =   charsToInt 0 xs
  | toSigned xs           =   charsToInt 0 xs

val toInt        = toSigned o String.explode

val newlineCount = List.length o List.filter (fn x => x = #"\n") o String.explode

%%

%header (functor TigerLexFun(structure Tokens : Tiger_TOKENS));
ws    = [\ \t\b\r]+;
digit = [0-9]+;
string = [a-zA-Z][a-zA-Z0-9]*;
comment = \/\*.*\*\/;
char = {string}|{ws}|\n;
quote = \";
%%
    
\n               => (updateLine 1;resetpos(); lex ()); 
"*"              => (updatepos (String.size yytext); Tokens.MUL         (!lineRef, !posRef));
"/"              => (updatepos (String.size yytext); Tokens.DIV         (!lineRef, !posRef));
"+"              => (updatepos (String.size yytext); Tokens.PLUS        (!lineRef, !posRef));
"-"              => (updatepos (String.size yytext); Tokens.MINUS       (!lineRef, !posRef));
">="             => (updatepos (String.size yytext); Tokens.GEQ         (!lineRef, !posRef));
"<="             => (updatepos (String.size yytext); Tokens.LEQ         (!lineRef, !posRef));
"="              => (updatepos (String.size yytext); Tokens.EQ          (!lineRef, !posRef));
"<>"             => (updatepos (String.size yytext); Tokens.NEQ         (!lineRef, !posRef));
">"              => (updatepos (String.size yytext); Tokens.GT          (!lineRef, !posRef));
"<"              => (updatepos (String.size yytext); Tokens.LT          (!lineRef, !posRef));
"&"              => (updatepos (String.size yytext); Tokens.AND         (!lineRef, !posRef));
"|"              => (updatepos (String.size yytext); Tokens.OR          (!lineRef, !posRef));
":="             => (updatepos (String.size yytext); Tokens.ASSIGN      (!lineRef, !posRef));
"["              => (updatepos (String.size yytext); Tokens.LBRAC       (!lineRef, !posRef));
"]"              => (updatepos (String.size yytext); Tokens.RBRAC       (!lineRef, !posRef));
"{"              => (updatepos (String.size yytext); Tokens.LBRACE      (!lineRef, !posRef));
"}"              => (updatepos (String.size yytext); Tokens.RBRACE      (!lineRef, !posRef));
"("              => (updatepos (String.size yytext); Tokens.LPAREN      (!lineRef, !posRef));
")"              => (updatepos (String.size yytext); Tokens.RPAREN      (!lineRef, !posRef));
","              => (updatepos (String.size yytext); Tokens.COMMA       (!lineRef, !posRef));
";"              => (updatepos (String.size yytext); Tokens.SEMICOLON   (!lineRef, !posRef));
":"              => (updatepos (String.size yytext); Tokens.COLON       (!lineRef, !posRef));
"."              => (updatepos (String.size yytext); Tokens.DOT         (!lineRef, !posRef));
"array"          => (updatepos (String.size yytext); Tokens.ARRAY       (!lineRef, !posRef));
"if"             => (updatepos (String.size yytext); Tokens.IF          (!lineRef, !posRef));
"then"           => (updatepos (String.size yytext); Tokens.THEN        (!lineRef, !posRef));
"else"           => (updatepos (String.size yytext); Tokens.ELSE        (!lineRef, !posRef));
"nil"            => (updatepos (String.size yytext); Tokens.NIL         (!lineRef, !posRef));
"type"           => (updatepos (String.size yytext); Tokens.TYPE        (!lineRef, !posRef));
"var"            => (updatepos (String.size yytext); Tokens.VAR         (!lineRef, !posRef));
"let"            => (updatepos (String.size yytext); Tokens.LET         (!lineRef, !posRef));
"in"             => (updatepos (String.size yytext); Tokens.IN          (!lineRef, !posRef));
"end"            => (updatepos (String.size yytext); Tokens.END         (!lineRef, !posRef));
"function"       => (updatepos (String.size yytext); Tokens.FUNCTION    (!lineRef, !posRef));
"break"          => (updatepos (String.size yytext); Tokens.BREAK       (!lineRef, !posRef));
"while"          => (updatepos (String.size yytext); Tokens.WHILE       (!lineRef, !posRef));
"for"            => (updatepos (String.size yytext); Tokens.FOR         (!lineRef, !posRef));
"to"             => (updatepos (String.size yytext); Tokens.TO          (!lineRef, !posRef));
"do"             => (updatepos (String.size yytext); Tokens.DO          (!lineRef, !posRef));
"of"             => (updatepos (String.size yytext); Tokens.OF          (!lineRef, !posRef));


{quote}{char}*{quote}     => (updatepos (String.size yytext); Tokens.STRING      (yytext, !lineRef, !posRef));
{ws}+            => (updatepos (String.size yytext); lex());
{digit}+         => (Tokens.INT (toInt yytext, !lineRef, !posRef));
{comment}        => (lex());
{string}         => (updatepos (String.size yytext); Tokens.ID          (yytext, !lineRef, !posRef));




